<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Discord Web Pinger + Auto Wordlist + Filters + Emoji</title>
  <style>
    * {
      margin: 0; padding: 0; box-sizing: border-box; user-select: none;
    }
    body {
      background-color: #0e0e0e;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      gap: 20px;
      padding: 30px;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    
    /* Starry background */
    .stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      overflow: hidden;
    }
    .star {
      position: absolute;
      background-color: white;
      border-radius: 50%;
      animation: twinkle var(--duration) infinite ease-in-out;
      opacity: 0;
    }
    @keyframes twinkle {
      0%, 100% { opacity: 0; }
      50% { opacity: var(--opacity); }
    }
    
    .container, .sidepanel, .sidepanel-small {
      background: rgba(17, 17, 17, 0.85);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 0 20px var(--glow-color, rgba(88, 101, 242, 0.6));
      display: flex;
      flex-direction: column;
      gap: 14px;
      flex-shrink: 0;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: box-shadow 0.3s ease;
    }
    .container {
      max-width: 620px;
      width: 100%;
    }
    .sidepanel {
      width: 400px;
      height: 580px;
      overflow-y: auto;
    }
    .sidepanel-small {
      width: 260px;
      height: 580px;
      overflow-y: auto;
    }
    h1, h2, h3 {
      font-weight: 700;
      letter-spacing: 1.2px;
    }
    h1 { font-size: 28px; }
    h2 { font-size: 20px; margin-bottom: 10px; user-select: none; }
    h3 { font-size: 16px; margin-bottom: 8px; }
    input[type=text], textarea {
      background: rgba(26, 26, 26, 0.8);
      border: 1px solid rgba(68, 68, 68, 0.5);
      color: white;
      padding: 12px 14px;
      font-size: 15px;
      border-radius: 6px;
      width: 100%;
      transition: border-color 0.25s ease, background 0.25s ease;
      resize: vertical;
    }
    input[type=text]:focus, textarea:focus {
      outline: none;
      border-color: var(--glow-color, #5865f2);
      background: rgba(34, 34, 34, 0.8);
    }
    textarea {
      min-height: 90px;
      max-height: 180px;
      font-family: monospace;
    }
    button {
      padding: 12px 0;
      background: var(--glow-color, #5865f2);
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 6px;
      font-weight: 700;
      font-size: 16px;
      letter-spacing: 0.8px;
      transition: all 0.25s ease;
      user-select: none;
    }
    button:hover:not(.active) {
      background: var(--glow-hover, #4752c4);
      transform: translateY(-1px);
    }
    button.active {
      background: var(--glow-active, #344ac7) !important;
    }
    label {
      font-size: 14px;
      user-select: none;
      margin-bottom: 6px;
      display: block;
    }
    .hud {
      position: fixed;
      top: 15px;
      right: 15px;
      background: rgba(24, 24, 24, 0.85);
      border-radius: 10px;
      padding: 15px;
      width: 340px;
      height: 580px;
      box-shadow: 0 0 20px var(--glow-color, rgba(88, 101, 242, 0.6));
      display: flex;
      flex-direction: column;
      font-size: 13px;
      color: #ddd;
      overflow: hidden;
      user-select: none;
      z-index: 9999;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .hud-header {
      font-weight: 700;
      font-size: 18px;
      margin-bottom: 12px;
      border-bottom: 1px solid rgba(68, 68, 68, 0.5);
      padding-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #messages {
      overflow-y: auto;
      flex-grow: 1;
      padding-right: 4px;
    }
    #messages::-webkit-scrollbar {
      width: 7px;
    }
    #messages::-webkit-scrollbar-thumb {
      background: var(--glow-color, #5865f2);
      border-radius: 4px;
    }
    #messages::-webkit-scrollbar-track {
      background: transparent;
    }
    .msg-entry {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      background: rgba(34, 34, 34, 0.6);
      padding: 6px 10px;
      border-radius: 8px;
      word-wrap: break-word;
      user-select: text;
      transition: transform 0.2s ease;
    }
    .msg-entry:hover {
      transform: translateX(3px);
    }
    .msg-entry img {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      flex-shrink: 0;
      background: #444;
    }
    .msg-content {
      max-width: 260px;
    }
    .msg-username {
      font-weight: 700;
      font-size: 14px;
      color: var(--glow-color, #5865f2);
      margin-bottom: 3px;
      user-select: text;
    }
    .msg-text {
      font-size: 13px;
      color: #ddd;
      white-space: pre-wrap;
      user-select: text;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
      user-select: none;
      flex-wrap: wrap;
    }
    .slider-container {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      font-size: 13px;
      color: #bbb;
      min-width: 150px;
    }
    input[type=range] {
      -webkit-appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 5px;
      background: #444;
      outline: none;
      margin-top: 5px;
      cursor: pointer;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--glow-color, #5865f2);
      cursor: pointer;
      border: 2px solid #333;
      transition: background 0.25s ease;
    }
    input[type=range]:hover::-webkit-slider-thumb {
      background: var(--glow-hover, #4752c4);
    }
    .toggle-buttons {
      display: flex;
      gap: 10px;
      user-select: none;
    }
    .toggle-buttons button {
      background: #333;
      color: #ddd;
      font-weight: 600;
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 6px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
      white-space: nowrap;
    }
    .toggle-buttons button.active {
      background: var(--glow-color, #5865f2);
      border-color: var(--glow-hover, #4752c4);
      color: white;
    }
    .file-upload {
      margin-top: 8px;
      font-size: 14px;
      user-select: none;
    }
    .file-upload input[type=file] {
      margin-top: 5px;
      cursor: pointer;
    }
    .auto-control, .emoji-control, .ping-position-control, .persistent-msg-control {
      margin-top: 10px;
      text-align: center;
      user-select: none;
    }
    .auto-control button, .emoji-control button, .ping-position-control button, .persistent-msg-control button {
      width: 100%;
      font-weight: 700;
      font-size: 16px;
    }
    .wordlist-textarea {
      height: 250px;
      font-family: monospace;
      font-size: 13px;
      resize: vertical;
      background: rgba(26, 26, 26, 0.8);
      border: 1px solid rgba(68, 68, 68, 0.5);
      color: white;
      padding: 12px 14px;
      border-radius: 6px;
      overflow-y: auto;
    }
    .filter-list {
      max-height: 210px;
      overflow-y: auto;
      margin-top: 8px;
      background: rgba(34, 34, 34, 0.6);
      border-radius: 6px;
      padding: 10px;
      font-size: 14px;
      user-select: text;
    }
    .filter-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      align-items: center;
      gap: 10px;
    }
    .filter-item div {
      flex-grow: 1;
      overflow-wrap: break-word;
    }
    .filter-item button {
      padding: 4px 10px;
      font-size: 13px;
      background: #722;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      color: white;
    }
    .filter-item button:hover {
      background: #a33;
    }
    input[type=text].filter-key, input[type=text].filter-reply {
      width: 100%;
      margin-bottom: 6px;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid rgba(68, 68, 68, 0.5);
      background: rgba(26, 26, 26, 0.8);
      color: white;
      font-size: 14px;
    }
    
    /* Modern input buttons */
    .input-group {
      display: flex;
      gap: 8px;
    }
    .input-group input {
      flex-grow: 1;
    }
    .input-group button {
      width: 40px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(88, 101, 242, 0.2);
      border: 1px solid rgba(88, 101, 242, 0.3);
    }
    .input-group button:hover {
      background: rgba(88, 101, 242, 0.4);
    }
    
    /* List displays for tokens/users/channels */
    .item-list {
      max-height: 100px;
      overflow-y: auto;
      background: rgba(34, 34, 34, 0.6);
      border-radius: 6px;
      padding: 8px;
      margin-top: 5px;
      font-size: 13px;
    }
    .list-item {
      display: flex;
      justify-content: space-between;
      padding: 4px 6px;
      border-radius: 4px;
      margin-bottom: 4px;
      background: rgba(68, 68, 68, 0.3);
    }
    .list-item:hover {
      background: rgba(88, 101, 242, 0.2);
    }
    .list-item button {
      background: transparent;
      border: none;
      color: #ff6b6b;
      padding: 0 4px;
      font-size: 12px;
    }
    
    /* Color picker */
    .color-picker {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 5px;
    }
    .color-picker input {
      width: 30px;
      height: 30px;
      padding: 0;
      border: none;
      background: transparent;
      cursor: pointer;
    }
    .color-picker span {
      font-size: 13px;
    }
    
    /* Glow effect */
    .glow {
      animation: glow-pulse 3s infinite alternate;
    }
    @keyframes glow-pulse {
      0% { box-shadow: 0 0 10px var(--glow-color, rgba(88, 101, 242, 0.6)); }
      100% { box-shadow: 0 0 20px var(--glow-color, rgba(88, 101, 242, 0.9)); }
    }
  </style>
</head>
<body>
  <!-- Starry background -->
  <div class="stars" id="stars"></div>
  
  <div class="container">
    <h1>Discord Web Pinger</h1>
    
    <!-- Multi-token input -->
    <div>
      <label>Tokens:</label>
      <div class="input-group">
        <input id="tokenInput" placeholder="Add Discord Token" autocomplete="off" spellcheck="false" />
        <button id="addTokenBtn">+</button>
      </div>
      <div class="item-list" id="tokenList"></div>
    </div>
    
    <!-- Multi-channel input -->
    <div>
      <label>Channel IDs:</label>
      <div class="input-group">
        <input id="channelInput" placeholder="Add Channel ID" autocomplete="off" spellcheck="false" />
        <button id="addChannelBtn">+</button>
      </div>
      <div class="item-list" id="channelList"></div>
    </div>
    
    <!-- Multi-user input -->
    <div>
      <label>User IDs to ping:</label>
      <div class="input-group">
        <input id="userInput" placeholder="Add User ID to ping" autocomplete="off" spellcheck="false" />
        <button id="addUserBtn">+</button>
      </div>
      <div class="item-list" id="userList"></div>
    </div>

    <div class="controls">
      <div class="slider-container">
        <label for="speedRange">Send Speed: <span id="speedValue">1000</span> ms</label>
        <input type="range" id="speedRange" min="200" max="5000" step="100" value="1000" />
      </div>
      <div class="toggle-buttons" title="Message Style">
        <button id="btnBold" class="active">Bold (#)</button>
        <button id="btnUnbold">Unbold</button>
      </div>
    </div>

    <textarea id="message" placeholder="Message to send" rows="5" spellcheck="false"></textarea>

    <div class="persistent-msg-control">
      <label for="persistentMsgInput" style="margin-bottom:6px;">Persistent message (appended to every send):</label>
      <textarea id="persistentMsgInput" rows="3" placeholder="Type message to always append, or leave empty to disable." spellcheck="false" style="resize: vertical;"></textarea>
      <button id="clearPersistentBtn" style="margin-top: 6px; background:#a33;">Remove Persistent Message</button>
    </div>

    <button id="sendBtn" class="glow">Send Message</button>

    <div class="ping-position-control">
      <label>Ping Position:</label>
      <div class="toggle-buttons" style="justify-content: center;">
        <button id="pingStart" class="active">Ping at Start</button>
        <button id="pingEnd">Ping at End</button>
      </div>
    </div>

    <div class="emoji-control">
      <button id="emojiAddBtn">Add Emoji</button>
      <button id="emojiRemoveBtn" style="display:none; background:#a33;">Remove Emoji</button>
    </div>
    
    <!-- UI Color Picker -->
    <div>
      <label>UI Glow Color:</label>
      <div class="color-picker">
        <input type="color" id="glowColorPicker" value="#5865f2" />
        <span id="glowColorHex">#5865f2</span>
        <button id="resetGlowColor" style="padding: 4px 8px; font-size: 12px;">Reset</button>
      </div>
    </div>
  </div>

  <div class="sidepanel">
    <h2>Wordlist / Auto Sender</h2>
    <label for="wordlistArea">Paste or type wordlist (lines and indented lines will send sequentially):</label>
    <textarea id="wordlistArea" class="wordlist-textarea" spellcheck="false" placeholder="Example:\nhello\n  world\nfoo\n  bar"></textarea>

    <label class="file-upload" for="fileInput">Or upload a .txt file:</label>
    <input type="file" id="fileInput" accept=".txt" />

    <div class="auto-control">
      <button id="autoToggleBtn">Start Auto Sending</button>
    </div>
  </div>

  <div class="sidepanel-small" style="padding-top: 4px;">
    <h2>Filters</h2>
    <label for="filterKeyword">Keyword to detect:</label>
    <input id="filterKeyword" type="text" placeholder="e.g. loser" autocomplete="off" spellcheck="false" class="filter-key" />
    <label for="filterReply">Reply to send:</label>
    <input id="filterReply" type="text" placeholder="e.g. I'm not a loser" autocomplete="off" spellcheck="false" class="filter-reply" />
    <button id="addFilterBtn" style="margin-bottom: 10px;">Add Filter</button>

    <div class="filter-list" id="filterList"></div>
  </div>

  <div class="hud" id="hud">
    <div class="hud-header">
      Channel Activity
      <button id="clearHudBtn" style="background: transparent; padding: 0; font-size: 12px;">Clear</button>
    </div>
    <div id="messages"></div>
  </div>

<script>
  // ====== STAR BACKGROUND ======
  function createStars() {
    const starsContainer = document.getElementById('stars');
    const starCount = 200;
    
    for (let i = 0; i < starCount; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      
      // Random properties for each star
      const size = Math.random() * 2 + 1;
      const x = Math.random() * 100;
      const y = Math.random() * 100;
      const duration = Math.random() * 5 + 3;
      const delay = Math.random() * 5;
      const opacity = Math.random() * 0.7 + 0.3;
      
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;
      star.style.left = `${x}%`;
      star.style.top = `${y}%`;
      star.style.setProperty('--duration', `${duration}s`);
      star.style.setProperty('--opacity', opacity);
      star.style.animationDelay = `${delay}s`;
      
      starsContainer.appendChild(star);
    }
  }
  
  // Initialize stars
  createStars();

  // ====== UI GLOW COLOR ======
  function updateGlowColor(color) {
    document.documentElement.style.setProperty('--glow-color', color);
    
    // Calculate hover and active colors
    const hoverColor = adjustColor(color, -20);
    const activeColor = adjustColor(color, -40);
    
    document.documentElement.style.setProperty('--glow-hover', hoverColor);
    document.documentElement.style.setProperty('--glow-active', activeColor);
    
    // Update hex display
    document.getElementById('glowColorHex').textContent = color;
  }
  
  // Helper to adjust color brightness
  function adjustColor(color, amount) {
    return '#' + color.replace(/^#/, '').replace(/../g, color => 
      ('0' + Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16).slice(-2)
    );
  }
  
  // Initialize color picker
  const glowColorPicker = document.getElementById('glowColorPicker');
  glowColorPicker.addEventListener('input', (e) => {
    updateGlowColor(e.target.value);
  });
  
  // Reset to default color
  document.getElementById('resetGlowColor').addEventListener('click', () => {
    glowColorPicker.value = '#5865f2';
    updateGlowColor('#5865f2');
  });

  // ====== MULTI-ITEM MANAGEMENT ======
  // Tokens, channels, and users will be stored in arrays
  let tokens = [];
  let channels = [];
  let users = [];
  
  // Render item lists
  function renderItemList(items, containerId, type) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    items.forEach((item, index) => {
      const div = document.createElement('div');
      div.className = 'list-item';
      div.innerHTML = `
        <span>${item.substring(0, 15)}${item.length > 15 ? '...' : ''}</span>
        <button data-index="${index}" data-type="${type}">×</button>
      `;
      container.appendChild(div);
    });
    
    // Add click handlers to remove buttons
    container.querySelectorAll('button').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.target.dataset.index);
        const type = e.target.dataset.type;
        
        switch(type) {
          case 'token': tokens.splice(index, 1); break;
          case 'channel': channels.splice(index, 1); break;
          case 'user': users.splice(index, 1); break;
        }
        
        renderItemList(items, containerId, type);
      });
    });
  }
  
  // Add item functions
  document.getElementById('addTokenBtn').addEventListener('click', () => {
    const token = document.getElementById('tokenInput').value.trim();
    if (token && !tokens.includes(token)) {
      tokens.push(token);
      renderItemList(tokens, 'tokenList', 'token');
      document.getElementById('tokenInput').value = '';
    }
  });
  
  document.getElementById('addChannelBtn').addEventListener('click', () => {
    const channel = document.getElementById('channelInput').value.trim();
    if (channel && !channels.includes(channel)) {
      channels.push(channel);
      renderItemList(channels, 'channelList', 'channel');
      document.getElementById('channelInput').value = '';
    }
  });
  
  document.getElementById('addUserBtn').addEventListener('click', () => {
    const user = document.getElementById('userInput').value.trim();
    if (user && !users.includes(user)) {
      users.push(user);
      renderItemList(users, 'userList', 'user');
      document.getElementById('userInput').value = '';
    }
  });
  
  // Allow Enter key to add items
  document.getElementById('tokenInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') document.getElementById('addTokenBtn').click();
  });
  document.getElementById('channelInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') document.getElementById('addChannelBtn').click();
  });
  document.getElementById('userInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') document.getElementById('addUserBtn').click();
  });

  // ====== REST OF THE APPLICATION ======
  // ELEMENTS
  const messageInput = document.getElementById('message');
  const sendBtn = document.getElementById('sendBtn');
  const messagesDiv = document.getElementById('messages');
  const speedRange = document.getElementById('speedRange');
  const speedValue = document.getElementById('speedValue');
  const btnBold = document.getElementById('btnBold');
  const btnUnbold = document.getElementById('btnUnbold');
  const wordlistArea = document.getElementById('wordlistArea');
  const fileInput = document.getElementById('fileInput');
  const autoToggleBtn = document.getElementById('autoToggleBtn');
  const pingStartBtn = document.getElementById('pingStart');
  const pingEndBtn = document.getElementById('pingEnd');
  const emojiAddBtn = document.getElementById('emojiAddBtn');
  const emojiRemoveBtn = document.getElementById('emojiRemoveBtn');
  const persistentMsgInput = document.getElementById('persistentMsgInput');
  const clearPersistentBtn = document.getElementById('clearPersistentBtn');
  const filterKeywordInput = document.getElementById('filterKeyword');
  const filterReplyInput = document.getElementById('filterReply');
  const addFilterBtn = document.getElementById('addFilterBtn');
  const filterListDiv = document.getElementById('filterList');
  const clearHudBtn = document.getElementById('clearHudBtn');

  // STATE
  let sendCooldown = parseInt(speedRange.value, 10);
  let lastSendTime = 0;
  let isBold = true;
  let autoSending = false;
  let autoTimer = null;
  let parsedWordlist = [];
  let flatWordlist = [];
  let autoIndex = 0;
  let pingAtStart = true;
  let emojiMode = null; // null, "react" or "append"
  let emojiChar = null;
  let persistentMessage = "";
  let sendingLocked = false; // to prevent spam send calls

  // FILTERS
  let filters = [];

  // HELPERS
  function sanitize(str) {
    if (!str) return '';
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/\'/g, "&#039;");
  }

  // === SPEED SLIDER ===
  speedRange.addEventListener('input', () => {
    sendCooldown = parseInt(speedRange.value, 10);
    speedValue.textContent = sendCooldown;
  });

  // === BOLD TOGGLE ===
  btnBold.addEventListener('click', () => {
    isBold = true;
    btnBold.classList.add('active');
    btnUnbold.classList.remove('active');
  });
  btnUnbold.addEventListener('click', () => {
    isBold = false;
    btnUnbold.classList.add('active');
    btnBold.classList.remove('active');
  });

  // === PING POSITION TOGGLE ===
  pingStartBtn.addEventListener('click', () => {
    pingAtStart = true;
    pingStartBtn.classList.add('active');
    pingEndBtn.classList.remove('active');
  });
  pingEndBtn.addEventListener('click', () => {
    pingAtStart = false;
    pingEndBtn.classList.add('active');
    pingStartBtn.classList.remove('active');
  });

  // === PERSISTENT MESSAGE ===
  persistentMsgInput.addEventListener('input', () => {
    persistentMessage = persistentMsgInput.value.trim();
  });
  clearPersistentBtn.addEventListener('click', () => {
    persistentMessage = "";
    persistentMsgInput.value = "";
  });

  // === EMOJI BUTTONS ===
  emojiAddBtn.addEventListener('click', () => {
    let emoji = prompt("Enter an emoji to add:");
    if (!emoji) return;

    let react = confirm("React to your own messages with this emoji? Click 'Cancel' to append emoji at message end.");
    if (react) {
      emojiMode = "react";
    } else {
      emojiMode = "append";
    }
    emojiChar = emoji;

    emojiAddBtn.style.display = "none";
    emojiRemoveBtn.style.display = "block";
  });
  emojiRemoveBtn.addEventListener('click', () => {
    emojiMode = null;
    emojiChar = null;
    emojiRemoveBtn.style.display = "none";
    emojiAddBtn.style.display = "block";
  });

  // === FILTERS UI ===
  function renderFilters() {
    filterListDiv.innerHTML = '';
    filters.forEach((f, i) => {
      const div = document.createElement('div');
      div.className = 'filter-item';
      div.innerHTML = `
        <div><b>${sanitize(f.keyword)}</b> → ${sanitize(f.reply)}</div>
        <button data-index="${i}">Remove</button>
      `;
      filterListDiv.appendChild(div);
    });
    [...filterListDiv.querySelectorAll('button')].forEach(btn => {
      btn.addEventListener('click', e => {
        const idx = parseInt(e.target.dataset.index);
        filters.splice(idx, 1);
        renderFilters();
      });
    });
  }
  addFilterBtn.addEventListener('click', () => {
    const kw = filterKeywordInput.value.trim();
    const rp = filterReplyInput.value.trim();
    if (!kw || !rp) {
      alert('Both keyword and reply are required');
      return;
    }
    filters.push({keyword: kw.toLowerCase(), reply: rp});
    filterKeywordInput.value = "";
    filterReplyInput.value = "";
    renderFilters();
  });
  renderFilters();

  // === PARSE WORDLIST WITH HIERARCHY ===
  function parseHierarchicalWordlist(text) {
    const lines = text.split(/\r?\n/);
    const result = [];
    for(let i=0; i<lines.length; i++) {
      let line = lines[i].trimEnd();
      if(line.length === 0) continue;

      if (!lines[i].startsWith(' ') && !lines[i].startsWith('\t')) {
        // top level word
        result.push(line.trim());
      } else {
        // indented line, treated as continuation
        result.push(line.trim());
      }
    }
    return result;
  }

  // LOAD WORDLIST
  function loadWordlist() {
    parsedWordlist = parseHierarchicalWordlist(wordlistArea.value);
    if(parsedWordlist.length === 0) {
      alert('Please enter a wordlist with at least one line.');
      return false;
    }
    flatWordlist = shuffleArray([...parsedWordlist]);
    autoIndex = 0;
    return true;
  }

  // SHUFFLE
  function shuffleArray(arr) {
    for(let i = arr.length -1; i>0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // === FILE UPLOAD FOR WORDLIST ===
  fileInput.addEventListener('change', e => {
    if(!e.target.files.length) return;
    const file = e.target.files[0];
    if(!file.name.endsWith('.txt')) {
      alert('Please upload a .txt file');
      return;
    }
    const reader = new FileReader();
    reader.onload = e => {
      wordlistArea.value = e.target.result;
    };
    reader.readAsText(file);
  });

  // === SEND MESSAGE FUNCTION ===
  async function sendMessage(rawMsg) {
    if(sendingLocked) return false;
    sendingLocked = true;

    if(tokens.length === 0 || channels.length === 0 || users.length === 0) {
      alert('Please add at least one token, channel ID, and user ID.');
      sendingLocked = false;
      return false;
    }

    // Randomly select a token, channel, and user
    const token = tokens[Math.floor(Math.random() * tokens.length)];
    const channelId = channels[Math.floor(Math.random() * channels.length)];
    const userId = users[Math.floor(Math.random() * users.length)];

    // Compose message:
    // format: bold (#) if enabled, ping either start or end, plus persistent message appended
    let msg = rawMsg.trim();

    // Add persistent message if any
    if(persistentMessage) {
      msg += `\n${persistentMessage}`;
    }

    // Compose ping with <@userId>
    const ping = `<@${userId}>`;

    if(isBold) {
      // add # + space at start of entire message (before ping if pingAtStart)
      if(pingAtStart) {
        msg = `# ${ping} ${msg}`;
      } else {
        msg = `${ping} # ${msg}`;
      }
    } else {
      if(pingAtStart) {
        msg = `${ping} ${msg}`;
      } else {
        msg = `${msg} ${ping}`;
      }
    }

    // Add emoji if emojiMode append
    if(emojiMode === "append" && emojiChar) {
      msg = msg + ' ' + emojiChar;
    }

    const url = `https://discord.com/api/v9/channels/${channelId}/messages`;
    try {
      const res = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': token,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({content: msg})
      });
      if(!res.ok) {
        const data = await res.json().catch(() => ({}));
        alert(`Failed to send message: ${res.status} ${res.statusText} ${data.message || ''}`);
        sendingLocked = false;
        return false;
      }
      const sentMsg = await res.json();

      // React if emojiMode react
      if(emojiMode === "react" && emojiChar) {
        // react to own message
        await fetch(`https://discord.com/api/v9/channels/${channelId}/messages/${sentMsg.id}/reactions/${encodeURIComponent(emojiChar)}/@me`, {
          method: 'PUT',
          headers: { 'Authorization': token }
        });
      }

      lastSendTime = Date.now();
      sendingLocked = false;
      return true;
    } catch (e) {
      alert('Error sending message: ' + e.message);
      sendingLocked = false;
      return false;
    }
  }

  // === SEND BUTTON & ENTER KEY ===
  sendBtn.addEventListener('click', () => {
    if (sendingLocked) return;
    sendMessage(messageInput.value);
  });

  messageInput.addEventListener('keydown', e => {
    if(e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (sendingLocked) return;
      sendMessage(messageInput.value);
    }
  });

  // === AUTO SENDING ===
  async function autoSendLoop() {
    if(!autoSending) return;
    if(parsedWordlist.length === 0) {
      if(!loadWordlist()) {
        stopAutoSending();
        return;
      }
    }
    if(autoIndex >= flatWordlist.length) {
      flatWordlist = shuffleArray([...parsedWordlist]);
      autoIndex = 0;
    }

    const phrase = flatWordlist[autoIndex];
    autoIndex++;

    await sendMessage(phrase);

    if(autoSending) {
      autoTimer = setTimeout(autoSendLoop, sendCooldown);
    }
  }

  function startAutoSending() {
    if(!loadWordlist()) return;
    autoSending = true;
    autoToggleBtn.textContent = 'Stop Auto Sending';
    autoSendLoop();
  }
  function stopAutoSending() {
    autoSending = false;
    autoToggleBtn.textContent = 'Start Auto Sending';
    if(autoTimer) {
      clearTimeout(autoTimer);
      autoTimer = null;
    }
  }
  autoToggleBtn.addEventListener('click', () => {
    if(autoSending) stopAutoSending();
    else startAutoSending();
  });

  // === POLL CHANNEL MESSAGES & FILTERS ===
  let pollTimer = null;
  let lastMessageTimestamp = 0;

  async function pollMessages() {
    if(tokens.length === 0 || channels.length === 0) return;
    
    // Use random token and channel
    const token = tokens[Math.floor(Math.random() * tokens.length)];
    const channelId = channels[Math.floor(Math.random() * channels.length)];
    
    try {
      const res = await fetch(`https://discord.com/api/v9/channels/${channelId}/messages?limit=30`, {
        headers: { Authorization: token }
      });
      if(!res.ok) return;
      const data = await res.json();

      messagesDiv.innerHTML = '';
      data.reverse().forEach(msg => {
        // Add to UI
        const div = document.createElement('div');
        div.className = 'msg-entry';

        const avatar = msg.author.avatar
          ? `https://cdn.discordapp.com/avatars/${msg.author.id}/${msg.author.avatar}.png?size=64`
          : 'https://cdn.discordapp.com/embed/avatars/0.png';

        div.innerHTML = `
          <img src="${avatar}" alt="pfp" />
          <div class="msg-content">
            <div class="msg-username">${sanitize(msg.author.username)} (${msg.author.id})</div>
            <div class="msg-text">${sanitize(msg.content)}</div>
          </div>
        `;
        messagesDiv.appendChild(div);

        // FILTER check - case insensitive, exact substring match
        filters.forEach(f => {
          if(msg.content.toLowerCase().includes(f.keyword.toLowerCase())) {
            // send reply (debounced)
            // Only reply if message isn't from us (to avoid loops)
            if(!users.includes(msg.author.id)) {
              setTimeout(() => sendMessage(f.reply), 100);
            }
          }
        });
      });
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    } catch {
      // silently fail
    }
  }

  function startPolling() {
    if(pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(pollMessages, 2000);
  }

  // Clear HUD messages
  clearHudBtn.addEventListener('click', () => {
    messagesDiv.innerHTML = '';
  });

  // Start polling when items are added
  document.getElementById('addTokenBtn').addEventListener('click', startPolling);
  document.getElementById('addChannelBtn').addEventListener('click', startPolling);
  document.getElementById('addUserBtn').addEventListener('click', startPolling);

  // UTILS
  function sanitize(str) {
    if(!str) return '';
    return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
  }

  // UTILS: shuffle
  function shuffleArray(arr) {
    for(let i = arr.length-1; i>0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Initialize glow color
  updateGlowColor('#5865f2');
</script>

</body>
</html>
